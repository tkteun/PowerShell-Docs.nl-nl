---
title: Alles wat u wilt weten over uitzonde ringen
description: Het afhandelen van fouten is slechts een deel van de levens duur van het schrijven van code.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: 94c39b0d36b948d3a62707ae8a3be00efe606434
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 09/11/2020
ms.locfileid: "90012558"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="c3f25-103">Alles wat u wilt weten over uitzonde ringen</span><span class="sxs-lookup"><span data-stu-id="c3f25-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="c3f25-104">Het afhandelen van fouten is slechts een deel van de levens duur van het schrijven van code.</span><span class="sxs-lookup"><span data-stu-id="c3f25-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="c3f25-105">We kunnen de voor waarden voor het verwachte gedrag vaak controleren en valideren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="c3f25-106">Wanneer het onverwachte gebeurt, gaan we uitzonde ringen verwerken.</span><span class="sxs-lookup"><span data-stu-id="c3f25-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="c3f25-107">U kunt uitzonde ringen die zijn gegenereerd door de code van andere gebruikers eenvoudig afhandelen of u kunt uw eigen uitzonde ringen genereren zodat anderen deze kunnen verwerken.</span><span class="sxs-lookup"><span data-stu-id="c3f25-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="c3f25-108">De [oorspronkelijke versie][] van dit artikel is gepubliceerd op de blog geschreven door [@KevinMarquette][] .</span><span class="sxs-lookup"><span data-stu-id="c3f25-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="c3f25-109">Het Power shell-team hartelijk dank voor het delen van deze inhoud met ons.</span><span class="sxs-lookup"><span data-stu-id="c3f25-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="c3f25-110">Raadpleeg zijn blog op [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="c3f25-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="c3f25-111">Basis terminologie</span><span class="sxs-lookup"><span data-stu-id="c3f25-111">Basic terminology</span></span>

<span data-ttu-id="c3f25-112">We moeten enkele basis termen best rijken voordat we naar deze functie gaan.</span><span class="sxs-lookup"><span data-stu-id="c3f25-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="c3f25-113">Uitzondering</span><span class="sxs-lookup"><span data-stu-id="c3f25-113">Exception</span></span>

<span data-ttu-id="c3f25-114">Een uitzonde ring is een gebeurtenis die wordt gemaakt wanneer het probleem niet kan worden opgelost met de normale fout afhandeling.</span><span class="sxs-lookup"><span data-stu-id="c3f25-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="c3f25-115">Als u een getal wilt delen door nul of als er onvoldoende geheugen beschikbaar is, zijn er voor beelden van iets dat een uitzonde ring veroorzaakt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="c3f25-116">Soms maakt de auteur van de code die u gebruikt uitzonde ringen voor bepaalde problemen wanneer deze zich voordoen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="c3f25-117">Genereren en Catchiseren</span><span class="sxs-lookup"><span data-stu-id="c3f25-117">Throw and Catch</span></span>

<span data-ttu-id="c3f25-118">Wanneer er een uitzonde ring optreedt, zeggen we dat er een uitzonde ring wordt gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="c3f25-119">Als u een gegenereerde uitzonde ring wilt verwerken, moet u deze opvangen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="c3f25-120">Als er een uitzonde ring wordt gegenereerd en deze niet wordt onderschept door iets, stopt het uitvoeren van het script.</span><span class="sxs-lookup"><span data-stu-id="c3f25-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="c3f25-121">De aanroep stack</span><span class="sxs-lookup"><span data-stu-id="c3f25-121">The call stack</span></span>

<span data-ttu-id="c3f25-122">De aanroep stack is de lijst met functies die elkaar hebben aangeroepen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="c3f25-123">Wanneer een functie wordt aangeroepen, wordt deze toegevoegd aan de stack of aan de bovenkant van de lijst.</span><span class="sxs-lookup"><span data-stu-id="c3f25-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="c3f25-124">Wanneer de functie wordt afgesloten of geretourneerd, wordt deze uit de stack verwijderd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="c3f25-125">Wanneer er een uitzonde ring wordt gegenereerd, wordt de aanroep stack gecontroleerd om een uitzonderings-handler te ondervangen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="c3f25-126">Afsluitende en niet-afsluit fouten</span><span class="sxs-lookup"><span data-stu-id="c3f25-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="c3f25-127">Een uitzonde ring is doorgaans een afsluit fout.</span><span class="sxs-lookup"><span data-stu-id="c3f25-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="c3f25-128">Een gegenereerde uitzonde ring wordt onderschept of de huidige uitvoering wordt beëindigd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="c3f25-129">Standaard wordt een niet-afsluit fout gegenereerd door en wordt er `Write-Error` een fout aan de uitvoer stroom toegevoegd zonder een uitzonde ring te genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="c3f25-130">`Write-Error`U moet dit doen omdat en andere niet-afsluit fouten de niet activeren `catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="c3f25-131">Een uitzonde ring inslikken</span><span class="sxs-lookup"><span data-stu-id="c3f25-131">Swallowing an exception</span></span>

<span data-ttu-id="c3f25-132">Dit is het geval wanneer u een fout ondervangt die alleen wordt onderdrukt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="c3f25-133">Doe dit met een waarschuwing omdat het zeer lastig is om problemen met het oplossen van problemen op te lossen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="c3f25-134">Basis syntaxis van opdracht</span><span class="sxs-lookup"><span data-stu-id="c3f25-134">Basic command syntax</span></span>

<span data-ttu-id="c3f25-135">Hier volgt een kort overzicht van de standaard syntaxis voor het afhandelen van uitzonde ringen in Power shell.</span><span class="sxs-lookup"><span data-stu-id="c3f25-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="c3f25-136">Sprong</span><span class="sxs-lookup"><span data-stu-id="c3f25-136">Throw</span></span>

<span data-ttu-id="c3f25-137">We hebben een uitzonde ring gegenereerd met het tref woord om onze eigen uitzonderings gebeurtenis te maken `throw` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="c3f25-138">Hiermee maakt u een runtime-uitzonde ring die een afsluit fout vormt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="c3f25-139">Het wordt verwerkt door een `catch` in een aanroepende functie of sluit het script af met een bericht als dit.</span><span class="sxs-lookup"><span data-stu-id="c3f25-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="c3f25-140">Schrijf fout-Error Action stoppen</span><span class="sxs-lookup"><span data-stu-id="c3f25-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="c3f25-141">Ik heb genoteerd dat `Write-Error` standaard geen afsluit fout wordt gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="c3f25-142">Als u opgeeft `-ErrorAction Stop` , wordt er `Write-Error` een afsluit fout gegenereerd die kan worden verwerkt met een `catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="c3f25-143">Hartelijk dank voor het maken van een Dailey voor een herinnering over het gebruik van `-ErrorAction Stop` deze methode.</span><span class="sxs-lookup"><span data-stu-id="c3f25-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="c3f25-144">Cmdlet-error Action stoppen</span><span class="sxs-lookup"><span data-stu-id="c3f25-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="c3f25-145">Als u `-ErrorAction Stop` een geavanceerde functie of cmdlet opgeeft, worden alle- `Write-Error` instructies omgezet in afsluit fouten die de uitvoering stoppen of die kunnen worden verwerkt door een `catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="c3f25-146">Try/catch</span><span class="sxs-lookup"><span data-stu-id="c3f25-146">Try/Catch</span></span>

<span data-ttu-id="c3f25-147">De manier waarop uitzonde ringen worden verwerkt in Power shell (en veel andere talen) is dat u eerst `try` een gedeelte van de code maakt en als er een fout optreedt, kunt u dat `catch` doen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="c3f25-148">Hier volgt een kort voor beeld.</span><span class="sxs-lookup"><span data-stu-id="c3f25-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="c3f25-149">Het `catch` script wordt alleen uitgevoerd als er een afsluit fout is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="c3f25-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="c3f25-150">Als de `try` uitvoering op de juiste wijze wordt uitgevoerd, wordt het overgeslagen `catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="c3f25-151">Try/finally</span><span class="sxs-lookup"><span data-stu-id="c3f25-151">Try/Finally</span></span>

<span data-ttu-id="c3f25-152">Soms is het niet nodig om een fout af te handelen, maar moet u nog steeds code uitvoeren als er een uitzonde ring optreedt of niet.</span><span class="sxs-lookup"><span data-stu-id="c3f25-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="c3f25-153">Een `finally` script heeft precies dat.</span><span class="sxs-lookup"><span data-stu-id="c3f25-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="c3f25-154">Bekijk dit voorbeeld:</span><span class="sxs-lookup"><span data-stu-id="c3f25-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="c3f25-155">Wanneer u een resource opent of er verbinding mee maakt, moet u deze sluiten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="c3f25-156">Als `ExecuteNonQuery()` er een uitzonde ring optreedt, wordt de verbinding niet gesloten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="c3f25-157">Dit is dezelfde code in een `try/finally` blok.</span><span class="sxs-lookup"><span data-stu-id="c3f25-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="c3f25-158">In dit voor beeld wordt de verbinding gesloten als er een fout optreedt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="c3f25-159">Het wordt ook gesloten als er geen fout is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="c3f25-159">It also is closed if there's no error.</span></span> <span data-ttu-id="c3f25-160">Het `finally` script wordt elke keer uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="c3f25-161">Omdat u de uitzonde ring niet ondervangt, wordt de aanroep stack nog steeds door gegeven.</span><span class="sxs-lookup"><span data-stu-id="c3f25-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="c3f25-162">Try/catch/finally</span><span class="sxs-lookup"><span data-stu-id="c3f25-162">Try/Catch/Finally</span></span>

<span data-ttu-id="c3f25-163">Het is volledig geldig om te gebruiken `catch` en samen te werken `finally` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="c3f25-164">In de meeste gevallen kunt u een of meer gebruiken, maar u kunt ook scenario's vinden waarin u beide gebruikt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="c3f25-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="c3f25-165">$PSItem</span></span>

<span data-ttu-id="c3f25-166">Nu we de basis principes van de weg hebben ontvangen, kunnen we een beetje dieper vinden.</span><span class="sxs-lookup"><span data-stu-id="c3f25-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="c3f25-167">Binnen het `catch` blok is er een automatische variabele ( `$PSItem` of `$_` ) van het type `ErrorRecord` met de details over de uitzonde ring.</span><span class="sxs-lookup"><span data-stu-id="c3f25-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="c3f25-168">Hier volgt een kort overzicht van een aantal van de belangrijkste eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="c3f25-169">In deze voor beelden hebt u een ongeldig pad gebruikt in `ReadAllText` om deze uitzonde ring te genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="c3f25-170">PSItem. ToString ()</span><span class="sxs-lookup"><span data-stu-id="c3f25-170">PSItem.ToString()</span></span>

<span data-ttu-id="c3f25-171">Dit geeft u het schone bericht dat u kunt gebruiken in logboek registratie en algemene uitvoer.</span><span class="sxs-lookup"><span data-stu-id="c3f25-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="c3f25-172">`ToString()` wordt automatisch aangeroepen als `$PSItem` binnen een teken reeks wordt geplaatst.</span><span class="sxs-lookup"><span data-stu-id="c3f25-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="c3f25-173">$PSItem. InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="c3f25-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="c3f25-174">Deze eigenschap bevat aanvullende informatie die door Power shell wordt verzameld over de functie of het script waarin de uitzonde ring is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="c3f25-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="c3f25-175">Hier volgt een `InvocationInfo` van de voor beeld-uitzonde ringen die ik heb gemaakt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="c3f25-176">In de belang rijke informatie ziet u de `ScriptName` , de `Line` code en de `ScriptLineNumber` locatie van de aanroep gestart.</span><span class="sxs-lookup"><span data-stu-id="c3f25-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="c3f25-177">$PSItem. ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="c3f25-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="c3f25-178">Met deze eigenschap wordt de volg orde van functie aanroepen weer gegeven waarmee u naar de code wordt gemeldd waarin de uitzonde ring is gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="c3f25-179">Ik maak alleen aanroepen voor functies in hetzelfde script, maar dit kan de aanroepen volgen als er meerdere scripts zijn betrokken.</span><span class="sxs-lookup"><span data-stu-id="c3f25-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="c3f25-180">$PSItem. Exception</span><span class="sxs-lookup"><span data-stu-id="c3f25-180">$PSItem.Exception</span></span>

<span data-ttu-id="c3f25-181">Dit is de werkelijke uitzonde ring die is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="c3f25-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="c3f25-182">$PSItem. Exception. Message</span><span class="sxs-lookup"><span data-stu-id="c3f25-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="c3f25-183">Dit is het algemene bericht met een beschrijving van de uitzonde ring en is een goed uitgangs punt bij het oplossen van problemen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="c3f25-184">De meeste uitzonde ringen hebben een standaard bericht, maar kunnen ook worden ingesteld op iets aangepast wanneer de uitzonde ring wordt gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="c3f25-185">Dit is ook het bericht dat wordt geretourneerd wanneer `$PSItem.ToString()` wordt gebeld als er niet één is ingesteld op de `ErrorRecord` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="c3f25-186">$PSItem. Exception. InnerException</span><span class="sxs-lookup"><span data-stu-id="c3f25-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="c3f25-187">Uitzonde ringen kunnen binnenste uitzonde ringen bevatten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="c3f25-188">Dit is vaak het geval wanneer de code die u aanroept een uitzonde ring ophaalt en een andere uitzonde ring genereert.</span><span class="sxs-lookup"><span data-stu-id="c3f25-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="c3f25-189">De oorspronkelijke uitzonde ring vindt plaats in de nieuwe uitzonde ring.</span><span class="sxs-lookup"><span data-stu-id="c3f25-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="c3f25-190">Ik ga dit later opnieuw door te praten over het opnieuw genereren van uitzonde ringen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="c3f25-191">$PSItem. Exception. StackTrace</span><span class="sxs-lookup"><span data-stu-id="c3f25-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="c3f25-192">Dit is de `StackTrace` voor de uitzonde ring.</span><span class="sxs-lookup"><span data-stu-id="c3f25-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="c3f25-193">Ik heb hierboven een item weer gegeven `ScriptStackTrace` , maar dit is voor de aanroepen naar beheerde code.</span><span class="sxs-lookup"><span data-stu-id="c3f25-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="c3f25-194">U krijgt deze Stack tracering alleen wanneer de gebeurtenis wordt gegenereerd op basis van beheerde code.</span><span class="sxs-lookup"><span data-stu-id="c3f25-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="c3f25-195">Ik bel een .NET Framework-functie rechtstreeks zodat deze allemaal in dit voor beeld kan worden weer geven.</span><span class="sxs-lookup"><span data-stu-id="c3f25-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="c3f25-196">Over het algemeen wanneer u een stack tracering bekijkt, zoekt u naar waar de code wordt gestopt en begint de systeem aanroepen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="c3f25-197">Werken met uitzonde ringen</span><span class="sxs-lookup"><span data-stu-id="c3f25-197">Working with exceptions</span></span>

<span data-ttu-id="c3f25-198">Er zijn meer uitzonde ringen dan de eigenschappen basis syntaxis en uitzonde ring.</span><span class="sxs-lookup"><span data-stu-id="c3f25-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="c3f25-199">Opgegeven uitzonde ringen voor inspringen</span><span class="sxs-lookup"><span data-stu-id="c3f25-199">Catching typed exceptions</span></span>

<span data-ttu-id="c3f25-200">U kunt selectief selecteren met de uitzonde ringen die u ondervangt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="c3f25-201">Uitzonde ringen hebben een type en u kunt het type uitzonde ring opgeven dat u wilt opvangen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="c3f25-202">Het uitzonderings type wordt voor elk `catch` blok gecontroleerd totdat er een wordt gevonden dat overeenkomt met uw uitzonde ring.</span><span class="sxs-lookup"><span data-stu-id="c3f25-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="c3f25-203">Het is belang rijk om te realiseren dat uitzonde ringen kunnen overnemen van andere uitzonde ringen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="c3f25-204">In het bovenstaande voor beeld `FileNotFoundException` neemt overgenomen van `IOException` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="c3f25-205">Als het `IOException` eerst was, wordt deze in plaats daarvan aangeroepen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="c3f25-206">Er wordt slechts één catch-blok aangeroepen, zelfs als er meerdere overeenkomsten zijn.</span><span class="sxs-lookup"><span data-stu-id="c3f25-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="c3f25-207">Als we er een hebben `System.IO.PathTooLongException` `IOException` gevonden, zouden ze wel overeenkomen, maar als we er een zouden hebben gehad, zouden we de stack zouden kunnen `InsufficientMemoryException` opvangen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="c3f25-208">Meerdere typen tegelijk catchiseren</span><span class="sxs-lookup"><span data-stu-id="c3f25-208">Catch multiple types at once</span></span>

<span data-ttu-id="c3f25-209">Het is mogelijk meerdere uitzonderings typen met dezelfde instructie te ondervangen `catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="c3f25-210">Hartelijk dank dat u `/u/Sheppard_Ra` deze toevoeging hebt Voorst Ellen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="c3f25-211">Getypte uitzonde ringen</span><span class="sxs-lookup"><span data-stu-id="c3f25-211">Throwing typed exceptions</span></span>

<span data-ttu-id="c3f25-212">U kunt getypte uitzonde ringen in Power shell genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="c3f25-213">In plaats van `throw` aan te roepen met een teken reeks:</span><span class="sxs-lookup"><span data-stu-id="c3f25-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="c3f25-214">Een uitzonderings versnelling als volgt gebruiken:</span><span class="sxs-lookup"><span data-stu-id="c3f25-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="c3f25-215">Maar u moet een bericht opgeven wanneer u het op deze manier doet.</span><span class="sxs-lookup"><span data-stu-id="c3f25-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="c3f25-216">U kunt ook een nieuw exemplaar van een uitzonde ring maken dat moet worden gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="c3f25-217">Het bericht is optioneel wanneer u dit doet, omdat het systeem standaard berichten bevat voor alle ingebouwde uitzonde ringen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="c3f25-218">Als u geen gebruik wilt maken van Power shell 5,0 of hoger, moet u de oudere `New-Object` benadering gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c3f25-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="c3f25-219">Door een getypte uitzonde ring te gebruiken, kunnen u (of anderen) de uitzonde ring ondervangen door het type zoals vermeld in de vorige sectie.</span><span class="sxs-lookup"><span data-stu-id="c3f25-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="c3f25-220">Schrijf fout-uitzonde ring</span><span class="sxs-lookup"><span data-stu-id="c3f25-220">Write-Error -Exception</span></span>

<span data-ttu-id="c3f25-221">We kunnen deze getypte uitzonde ringen toevoegen aan `Write-Error` en we kunnen nog steeds `catch` fouten opleveren op uitzonderings type.</span><span class="sxs-lookup"><span data-stu-id="c3f25-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="c3f25-222">Gebruiken `Write-Error` als in de volgende voor beelden:</span><span class="sxs-lookup"><span data-stu-id="c3f25-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="c3f25-223">Vervolgens kunnen we deze als volgt ondervangen:</span><span class="sxs-lookup"><span data-stu-id="c3f25-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="c3f25-224">De grote lijst met .NET-uitzonde ringen</span><span class="sxs-lookup"><span data-stu-id="c3f25-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="c3f25-225">Ik heb een hoofd lijst gecompileerd met de hulp van de [Reddit/r/Power shell-Community][] die honderden .net-uitzonde ringen bevat om dit bericht aan te vullen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="c3f25-226">[De grote lijst met .NET-uitzonde ringen][]</span><span class="sxs-lookup"><span data-stu-id="c3f25-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="c3f25-227">Zoek vervolgens naar de lijst met uitzonde ringen die vergelijkbaar zijn met die van mijn situatie.</span><span class="sxs-lookup"><span data-stu-id="c3f25-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="c3f25-228">Probeer uitzonde ringen in de basis `System` naam ruimte te gebruiken.</span><span class="sxs-lookup"><span data-stu-id="c3f25-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="c3f25-229">Uitzonde ringen zijn objecten</span><span class="sxs-lookup"><span data-stu-id="c3f25-229">Exceptions are objects</span></span>

<span data-ttu-id="c3f25-230">Als u veel typen uitzonde ringen gaat gebruiken, moet u er rekening mee houden dat ze objecten zijn.</span><span class="sxs-lookup"><span data-stu-id="c3f25-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="c3f25-231">Verschillende uitzonde ringen hebben verschillende constructors en eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="c3f25-232">Als we de [FileNotFoundException][] -documentatie voor zien `System.IO.FileNotFoundException` , zien we dat we een bericht en een bestandspad kunnen door geven.</span><span class="sxs-lookup"><span data-stu-id="c3f25-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="c3f25-233">En het heeft een `FileName` eigenschap waarmee het bestandspad wordt weer gegeven.</span><span class="sxs-lookup"><span data-stu-id="c3f25-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="c3f25-234">Raadpleeg de .net- [documentatie][] voor andere constructors en object eigenschappen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="c3f25-235">Een uitzonde ring opnieuw genereren</span><span class="sxs-lookup"><span data-stu-id="c3f25-235">Re-throwing an exception</span></span>

<span data-ttu-id="c3f25-236">Als alles wat u in uw blok wilt doen `catch` `throw` , dezelfde uitzonde ring is, is `catch` dat niet het geval.</span><span class="sxs-lookup"><span data-stu-id="c3f25-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="c3f25-237">U moet alleen `catch` een uitzonde ring hebben die u van plan bent te verwerken of een actie uit te voeren wanneer dit gebeurt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="c3f25-238">Er zijn momenten waarop u een actie wilt uitvoeren op een uitzonde ring, maar de uitzonde ring opnieuw wilt genereren, zodat er iets kan worden gedaan met de uitvoering.</span><span class="sxs-lookup"><span data-stu-id="c3f25-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="c3f25-239">We kunnen een bericht schrijven of het probleem in het logboek registreren op het punt waar we het vinden, maar verwerken het probleem verder op de stack.</span><span class="sxs-lookup"><span data-stu-id="c3f25-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="c3f25-240">Interessant genoeg, we kunnen aanroepen `throw` vanuit de `catch` en de huidige uitzonde ring opnieuw genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="c3f25-241">We willen de uitzonde ring opnieuw genereren om de oorspronkelijke uitvoerings informatie, zoals het bron script en het regel nummer, te bewaren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="c3f25-242">Als we op dit moment een nieuwe uitzonde ring genereren, wordt de uitzonde ring gestart.</span><span class="sxs-lookup"><span data-stu-id="c3f25-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="c3f25-243">Nieuwe uitzonde ring opnieuw activeren</span><span class="sxs-lookup"><span data-stu-id="c3f25-243">Re-throwing a new exception</span></span>

<span data-ttu-id="c3f25-244">Als u een uitzonde ring ondervangt, maar u een ander wilt doen, moet u de oorspronkelijke uitzonde ring in het nieuwe item nesten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="c3f25-245">Hierdoor kan iemand de stack benaderen als `$PSItem.Exception.InnerException` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="c3f25-246">$PSCmdlet. ThrowTerminatingError ()</span><span class="sxs-lookup"><span data-stu-id="c3f25-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="c3f25-247">Het enige wat ik niet bevalt met het gebruik `throw` van onbewerkte uitzonde ringen is dat het fout bericht verwijst naar de `throw` instructie en geeft aan dat de regel het probleem is.</span><span class="sxs-lookup"><span data-stu-id="c3f25-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="c3f25-248">Wanneer het fout bericht wordt weer gegeven dat mijn script is beschadigd omdat ik `throw` op regel 31 werd aangeroepen, is er een onjuist bericht voor gebruikers van uw script.</span><span class="sxs-lookup"><span data-stu-id="c3f25-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="c3f25-249">Er zijn geen nuttige informatie.</span><span class="sxs-lookup"><span data-stu-id="c3f25-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="c3f25-250">Met Dexter Dhami is aangegeven dat ik dit kan `ThrowTerminatingError()` oplossen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="c3f25-251">Als we ervan uitgaan dat `ThrowTerminatingError()` in een functie met de naam wordt aangeroepen `Get-Resource` , is dit de fout die wordt weer geven.</span><span class="sxs-lookup"><span data-stu-id="c3f25-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="c3f25-252">Ziet u hoe de `Get-Resource` functie als de bron van het probleem wijst?</span><span class="sxs-lookup"><span data-stu-id="c3f25-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="c3f25-253">Dit geeft aan dat de gebruiker iets handig is.</span><span class="sxs-lookup"><span data-stu-id="c3f25-253">That tells the user something useful.</span></span>

<span data-ttu-id="c3f25-254">Omdat `$PSItem` dit een is `ErrorRecord` , kunnen we `ThrowTerminatingError` deze manier ook gebruiken om opnieuw te genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="c3f25-255">Hiermee wijzigt u de bron van de fout in de cmdlet en verbergt u de interne functies van de functie van de gebruikers van uw cmdlet.</span><span class="sxs-lookup"><span data-stu-id="c3f25-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="c3f25-256">Probeer afsluit fouten te maken</span><span class="sxs-lookup"><span data-stu-id="c3f25-256">Try can create terminating errors</span></span>

<span data-ttu-id="c3f25-257">Kirk Munro wijst op dat sommige uitzonde ringen alleen afsluit fouten bevatten wanneer ze in een blok worden uitgevoerd `try/catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="c3f25-258">Hier ziet u dat er een deling door een runtime-uitzonde ring door nul wordt gegenereerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="c3f25-259">Vervolgens roept u dit als volgt aan om te zien hoe de fout wordt gegenereerd en wordt het bericht nog steeds uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="c3f25-260">Maar door dezelfde code te plaatsen in een `try/catch` , zien we iets anders.</span><span class="sxs-lookup"><span data-stu-id="c3f25-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="c3f25-261">Er wordt een fout melding weer gegeven dat er een afsluit fout optreedt en het eerste bericht niet wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="c3f25-262">Wat ik niet bevalt, is dat u deze code kunt gebruiken in een functie en anders reageert als iemand een `try/catch` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="c3f25-263">Ik heb geen problemen met deze mezelf ondertreden, maar het is een belang rijk deel van het geval te weten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="c3f25-264">$PSCmdlet. ThrowTerminatingError () binnen try/catch</span><span class="sxs-lookup"><span data-stu-id="c3f25-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="c3f25-265">Eén nuance van `$PSCmdlet.ThrowTerminatingError()` is dat er een afsluit fout binnen uw cmdlet wordt gemaakt, maar er wordt een niet-afsluit fout weer gegenereerd nadat de cmdlet is achtergelaten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="c3f25-266">Dit laat de belasting van de oproepende functie van de functies zien om te bepalen hoe de fout moet worden afgehandeld.</span><span class="sxs-lookup"><span data-stu-id="c3f25-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="c3f25-267">Ze kunnen deze weer omzetten in een afsluit fout door deze te gebruiken `-ErrorAction Stop` of aan te roepen vanuit een `try{...}catch{...}` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="c3f25-268">Sjablonen voor open bare functies</span><span class="sxs-lookup"><span data-stu-id="c3f25-268">Public function templates</span></span>

<span data-ttu-id="c3f25-269">Een van de laatste een manier waarop ik met Kirk Munro werd gecommuniceerd, was dat hij een `try{...}catch{...}` rond elke en `begin` `process` `end` blok keren in al zijn geavanceerde functies.</span><span class="sxs-lookup"><span data-stu-id="c3f25-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="c3f25-270">In deze generieke vangst blokken heeft hij één regel die gebruikmaakt `$PSCmdlet.ThrowTerminatingError($PSItem)` van alle uitzonde ringen die zijn functies verlaten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="c3f25-271">Omdat alles zich in een `try` instructie binnen zijn functions bevindt, gebeurt alles consistent.</span><span class="sxs-lookup"><span data-stu-id="c3f25-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="c3f25-272">Dit geeft ook schone fouten aan de eind gebruiker die de interne code van de gegenereerde fout verbergt.</span><span class="sxs-lookup"><span data-stu-id="c3f25-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="c3f25-273">Overlapping</span><span class="sxs-lookup"><span data-stu-id="c3f25-273">Trap</span></span>

<span data-ttu-id="c3f25-274">Ik heb gestreefd over het `try/catch` aspect van uitzonde ringen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="c3f25-275">Maar er is één verouderde functie die ik moet vermelden voordat we dit in de omloop zetten.</span><span class="sxs-lookup"><span data-stu-id="c3f25-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="c3f25-276">A `trap` wordt in een script of functie geplaatst om alle uitzonde ringen die in dat bereik plaatsvinden, te ondervangen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="c3f25-277">Wanneer er een uitzonde ring optreedt, wordt de code in de `trap` uitgevoerd en vervolgens wordt de code normaal voortgezet.</span><span class="sxs-lookup"><span data-stu-id="c3f25-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="c3f25-278">Als er meerdere uitzonde ringen optreden, wordt de trap boven en boven genoemd.</span><span class="sxs-lookup"><span data-stu-id="c3f25-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="c3f25-279">Ik heb deze aanpak nooit goedgekeurd, maar ik zie de waarde in de beheerders-of controller scripts waarmee alle uitzonde ringen worden vastgelegd, en ga daarna nog verder met uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="c3f25-280">Opmerkingen sluiten</span><span class="sxs-lookup"><span data-stu-id="c3f25-280">Closing remarks</span></span>

<span data-ttu-id="c3f25-281">Het toevoegen van de juiste uitzonderings afhandeling aan uw scripts is dat ze niet alleen stabieler maken, maar het is ook eenvoudiger om deze uitzonde ringen op te lossen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="c3f25-282">Ik heb veel tijd besteed aan `throw` het praten omdat het een kern concept is voor het afhandelen van uitzonde ringen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="c3f25-283">Power Shell heeft ons ook `Write-Error` de omstandigheden afhandelen die u zou gebruiken `throw` .</span><span class="sxs-lookup"><span data-stu-id="c3f25-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="c3f25-284">Het is dus niet belang rijk dat u deze moet gebruiken `throw` nadat u dit hebt gelezen.</span><span class="sxs-lookup"><span data-stu-id="c3f25-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="c3f25-285">Nu u de tijd hebt genomen voor het schrijven van uitzonde ringen in deze details, gaat ik overschakelen naar het gebruik van `Write-Error -Stop` om fouten in mijn code te genereren.</span><span class="sxs-lookup"><span data-stu-id="c3f25-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="c3f25-286">Ook gaat u Kirk-advies nemen en de `ThrowTerminatingError` uitzonderings-handler van mijn goto maken voor elke functie.</span><span class="sxs-lookup"><span data-stu-id="c3f25-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[oorspronkelijke versie]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/Power shell-Community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[De grote lijst met .NET-uitzonde ringen]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET-documentatie]: /dotnet/api
[.NET documentation]: /dotnet/api
